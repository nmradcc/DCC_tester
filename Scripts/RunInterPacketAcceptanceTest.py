#!/usr/bin/env python3
"""
RunInterPacketAcceptanceTest Script
====================================

This script runs multiple iterations of the InterPacketAcceptanceTest
to verify NEM 671 inter-packet delay requirements.

The test is configured via RunInterPacketAcceptanceTestConfig.txt in the Scripts folder with:
    - Inter-packet delay (default: 1000ms)
    - Number of passes (default: 10)
    - COM port and locomotive address

If any iteration fails, the test aborts immediately.
"""

import sys
import os
import serial
import importlib.util
import msvcrt
import System

script_dir = os.path.dirname(os.path.abspath(__file__))

def load_packet_acceptance_module(file_path, module_name):
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    if spec is None or spec.loader is None:
        raise ImportError(f"Unable to load module from {file_path}")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module


def _parse_bool(value, key):
    if isinstance(value, bool):
        return value
    if value is None:
        raise ValueError(f"Missing boolean value for '{key}'")
    normalized = str(value).strip().lower()
    if normalized in {"y", "yes", "true", "1"}:
        return True
    if normalized in {"n", "no", "false", "0"}:
        return False
    raise ValueError(f"Invalid boolean value for '{key}': {value}")


def _parse_int(value, key):
    if value is None or str(value).strip() == "":
        raise ValueError(f"Missing integer value for '{key}'")
    try:
        return int(str(value).strip())
    except ValueError as exc:
        raise ValueError(f"Invalid integer value for '{key}': {value}") from exc


def load_test_config(config_path):
    """Load test configuration from a simple key=value text file."""
    if not os.path.exists(config_path):
        raise FileNotFoundError(f"Configuration file not found: {config_path}")

    config = {}
    with open(config_path, "r", encoding="utf-8") as config_file:
        for raw_line in config_file:
            line = raw_line.strip()
            if not line or line.startswith("#") or line.startswith(";"):
                continue
            if "=" not in line:
                raise ValueError(f"Invalid config line (expected key=value): {raw_line.strip()}")
            key, value = line.split("=", 1)
            config[key.strip()] = value.strip()

    required_keys = {
        "address",
        "inter_packet_delay_ms",
        "delta_ms",
        "pass_count",
        "stop_on_failure",
        "wait_key_press",
    }

    missing = sorted(required_keys - set(config.keys()))
    if missing:
        raise ValueError(f"Missing required config keys: {', '.join(missing)}")

    return {
        "address": _parse_int(config.get("address"), "address"),
        "inter_packet_delay_ms": _parse_int(config.get("inter_packet_delay_ms"), "inter_packet_delay_ms"),
        "delta_ms": _parse_int(config.get("delta_ms"), "delta_ms"),
        "pass_count": _parse_int(config.get("pass_count"), "pass_count"),
        "stop_on_failure": _parse_bool(config.get("stop_on_failure"), "stop_on_failure"),
        "wait_key_press": _parse_bool(config.get("wait_key_press"), "wait_key_press"),
    }


def wait_for_key_press(log):
    """Wait for any key press. 'c' captures screen, 'q' quits, any other key continues."""
    log(1, "Press any key to continue ('c' to capture screen, 'q' to quit)...")

    key = msvcrt.getch()

    try:
        key_char = key.decode('utf-8').lower()
    except Exception:
        key_char = ''

    if key_char == 'c':
        log(1, "✓ 'c' pressed - capturing screen, press Enter or add optional file name prefix text...")
        System.capture_screen(prefix="interpacket_test", interactive=True)
    elif key_char == 'q':
        log(1, "✓ 'q' pressed - quitting test...")
        raise KeyboardInterrupt("User requested early exit")
    else:
        log(1, "✓ Key pressed, continuing...")


def main():
    """Main entry point."""
    
    print("=" * 70)
    print("DCC InterPacket Acceptance Test Runner")
    print("NEM 671 Compliance Testing")
    print("=" * 70)
    print()
    print("This script will run multiple iterations of the InterPacket Acceptance")
    print("test to verify NEM 671 compliance.")
    print()
    print("If any iteration fails, the test will continue unless stop on failure is enabled.")
    print()
    
    config_path = os.path.join(script_dir, "RunInterPacketAcceptanceTestConfig.txt")
    try:
        config = load_test_config(config_path)
    except (FileNotFoundError, ValueError) as exc:
        print(f"ERROR: {exc}")
        print("Please update RunInterPacketAcceptanceTestConfig.txt with valid values.")
        return 1

    # Get system-level configuration
    sys_config = System.get_config()

    address = config["address"]
    start_delay_ms = config["inter_packet_delay_ms"]
    delta_ms = config["delta_ms"]
    pass_count = config["pass_count"]
    stop_on_failure = config["stop_on_failure"]
    wait_key_press = config["wait_key_press"]

    if delta_ms <= 0:
        print("ERROR: delta_ms must be > 0")
        return 1
    
    # Get system-level settings
    logging_level = sys_config.logging_level
    port = sys_config.serial_port
    
    packet_data_dir = os.path.join(script_dir, "PacketData")
    packet_module_path = os.path.join(packet_data_dir, "InterPacketAcceptanceTest.py")

    packet_module = load_packet_acceptance_module(
        packet_module_path,
        "packet_acceptance_no_motor"
    )

    DCCTesterRPC = packet_module.DCCTesterRPC
    run_interpacket_acceptance_test = packet_module.run_interpacket_acceptance_test
    log = packet_module.log
    set_log_level = packet_module.set_log_level

    set_log_level(logging_level)

    log(1, "")
    log(1, "=" * 70)
    log(1, "Configuration Summary:")
    log(1, "=" * 70)
    log(1, "System Parameters:")
    log(1, f"  Serial port:        {port}")
    log(1, f"  Logging level:      {logging_level}")
    log(1, "")
    log(1, "Test Parameters:")
    log(1, f"  Locomotive address: {address}")
    log(1, f"  Initial delay:      {start_delay_ms} ms")
    log(1, f"  Delay decrement:    {delta_ms} ms")
    log(1, f"  Number of passes:   {pass_count}")
    log(1, f"  Stop on failure:    {stop_on_failure}")
    log(1, f"  Wait key press:     {wait_key_press}")
    log(1, "=" * 70)
    log(1, "")
    
    log(2, "")
    log(2, "=" * 70)
    log(2, "Starting Test Run")
    log(2, "=" * 70)
    log(2, "")
    
    try:
        # Connect to DCC_tester
        log(2, f"Connecting to {port}...")
        rpc = DCCTesterRPC(port)
        log(2, "✓ Connected!\n")
        
        # Run test iterations
        passed_count = 0
        failed_count = 0
        total_tests = 0
        
        for i in range(1, pass_count + 1):
            log(2, "")
            log(2, "=" * 70)
            log(2, f"Test Pass {i} of {pass_count}")
            log(2, "=" * 70)
            log(2, "")

            current_delay_ms = start_delay_ms
            while current_delay_ms >= 0:
                total_tests += 1
                log(1, f"Step A: Inter-packet delay test at {current_delay_ms} ms")

                result = run_interpacket_acceptance_test(
                    rpc,
                    address,
                    current_delay_ms,
                    logging_level=logging_level,
                )

                if result.get("status") == "PASS":
                    passed_count += 1
                    log(1, f"✓ Delay {current_delay_ms} ms passed")
                else:
                    failed_count += 1
                    log(1, "")
                    log(1, f"✗ Delay {current_delay_ms} ms FAILED")
                    log(1, f"Error: {result.get('error', 'Unknown error')}")

                    if stop_on_failure:
                        log(1, "")
                        log(1, "=" * 70)
                        log(1, "TEST ABORTED DUE TO FAILURE")
                        log(1, "=" * 70)
                        log(1, "\nResults Summary:")
                        log(1, f"  Pass index:        {i}/{pass_count}")
                        log(1, f"  Delay at failure:  {current_delay_ms} ms")
                        log(1, f"  Total tests run:   {total_tests}")
                        log(1, f"  Passed:            {passed_count}")
                        log(1, f"  Failed:            {failed_count}")
                        log(1, "")
                        rpc.close()
                        return 1

                next_delay_ms = current_delay_ms - delta_ms

                if wait_key_press and next_delay_ms >= 0:
                    log(1, "")
                    wait_for_key_press(log)

                current_delay_ms = next_delay_ms
        
        # All tests complete
        log(1, "")
        log(1, "=" * 70)
        if failed_count == 0:
            log(1, "ALL TESTS COMPLETED SUCCESSFULLY")
        else:
            log(1, "TEST RUN COMPLETED WITH FAILURES")
        log(1, "=" * 70)
        log(1, "\nResults Summary:")
        log(1, f"  Pass loops:         {pass_count}")
        log(1, f"  Delay range:        {start_delay_ms} -> 0 ms (step {delta_ms} ms)")
        log(1, f"  Total tests:        {total_tests}")
        log(1, f"  Passed:             {passed_count}")
        log(1, f"  Failed:             {failed_count}")
        if total_tests > 0:
            success_rate = (passed_count * 100.0) / total_tests
            log(1, f"  Success rate:       {success_rate:.1f}%")
        log(1, "")
        log(1, "✓ Delay sweep complete")
        log(1, "")
        
        # Close connection
        rpc.close()
        return 0 if failed_count == 0 else 1
        
    except serial.SerialException as e:
        log(1, f"\nERROR: Serial port error: {e}")
        log(1, f"Make sure {port} is the correct port and the device is connected.")
        return 1
    except KeyboardInterrupt:
        log(1, "\n\nTest interrupted by user.")
        log(1, "")
        log(1, "=" * 70)
        log(1, "Results Summary (Partial):")
        log(1, "=" * 70)
        log(1, f"  Completed passes: {passed_count + failed_count}")
        log(1, f"  Passed: {passed_count}")
        log(1, f"  Failed: {failed_count}")
        log(1, "")
        return 1
    except Exception as e:
        log(1, f"\nERROR: Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
